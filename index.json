[{"content":"  As an Android developer, I always wanted to see how people would react to my apps. There are several ways a user could give feedback - through an email, over social media networks like Twitter, etc. But Play store rating and review is always been a crucial part of any app. It will not only help us getting the user feedback but on the other hand, it helps users to decide which app to choose from a similar category based on the ratings.\nThat being said, how would you encourage your users to give feedback on your app? You either provide a button asking Review somewhere in the NavigationDrawer/Toolbar or trigger the review popup after a user has experienced enough of your app. But when a user clicks on the button, we usually end up redirecting the user to the Play store app detail screenüòë We never wanted our customers to leave our application, but with this flow, we were forced to redirect the control to Play store app.\n‚Ä¢ ‚Ä¢ ‚Ä¢ But Google finally heard us! They have introduced a new shiny API for in-app review functionalityüòé With this API we can present a popup \u0026amp; ask for Review inside the app without having to redirect to Playstore. That‚Äôs Awesome, isn\u0026rsquo;t it? Let‚Äôs learn all about it in this article.\nMinimum requirements  Android devices should be running on Android 5.0 (API level 21) or higher and should have Google play store installed. Chrome OS devices that have Google play store app installed. Play core library with v1.8.0 or higher.  Design guidelines \u0026amp; Quota restrictions  The Review card (popup) should not be tampered or altered by modifying the design. Any overlay should not be added on top or around the card. Review dialog should not be programmatically removed (It will automatically be removed based on user actions) To protect user privacy and avoid API misuse, this API has a limited quota per user. Hence this functionality should not be triggered on a button click. Before presenting the Review card, the app should not ask user opinions like ‚ÄúDo you like the app?‚Äù or ‚ÄúGive this app 5 stars‚Äù, etc.  ‚Ä¢ ‚Ä¢ ‚Ä¢ Let‚Äôs Implement!  Add play-core library as a dependency in your build.gradle file.  1  implementation \u0026#39;com.google.android.play:core:1.8.0\u0026#39;   Create a ReviewManager instance and request ReviewInfo object. The ReviewInfo object to be pre-cached before calling launchReviewFlow method. So, it should be fetched ahead of time.  1 2 3 4 5 6 7 8 9 10 11  private var reviewInfo: ReviewInfo? = null val manager = ReviewManagerFactory.create(context) val request = manager.requestReviewFlow() requestFlow.addOnCompleteListener { request -\u0026gt; if (request.isSuccessful) { //Received ReviewInfo object  reviewInfo = request.result } else { //Problem in receiving object  reviewInfo = null }   Now, you can trigger launchReviewFlow to present the Review card to the user. It is suggested to show the review flow after the user has experienced enough of your app or game.  1 2 3 4 5 6  reviewInfo?.let { val flow = reviewManager.launchReviewFlow(this@MainActivity, it) flow.addOnCompleteListener { //Irrespective of the result, the app flow should continue  } }   That‚Äôs it! your app is all set‚úåÔ∏è\n‚Ä¢ ‚Ä¢ ‚Ä¢ Testing While I was testing the app, I made a few mistakes. I‚Äôll list it out here so that you won‚Äôt make the same mistakes that I did.\n We often test the new functionalities by creating a new project that would have new ApplicationId. In this case, while you test the app, make sure you give an ApplicationId that is already released and available in the play store. If you have given feedback in the past for your app, in-app review API‚Äôs launchReviewFlow will not present any Review card. It simply triggers a success event. Due to quota limitations, calling a launchReviewFlow method might not always display a dialog. It should not be linked with any button click event. To test one of my apps, I had to create a signed apk to see the Review card but for the other app, debug build worked just fine. To check other design guidelines and when to display a review card, refer to the official document here.  ‚Ä¢ ‚Ä¢ ‚Ä¢ I have created a sample app to implement \u0026amp; test the functionality. You can refer to the source code for more understanding.\nThat‚Äôs everything for today.\n Buy me a coffee?\nIf you like this article, you can buy me a coffee. Thanks!\n ","description":"Exploring Android's new In-app review API","id":2,"section":"posts","tags":["android","in-app review"],"title":"Integrating In-App Review API into Android App","uri":"https://naveentp.github.io/posts/android-in-app-review-api/"},{"content":" \nHello worldüëã, I\u0026rsquo;m Naveen! About me  Software Engineer Native mobile app developer (#iOS, #Android) Open-source enthusiast I write technical stuff at Medium  Mentions  Android LibHunt #169 (Awesome Jetpack compose A collaborative list of awesome jetpack compose resources) Android Weekly #378 (Awesome Jetpack compose A collaborative list of awesome jetpack compose resources) Android LibHunt #156 (Clean-MVVM-NewsApp An Android application built using Clean + MVVM architecture) AndroidDev Digest #221 (Preference Helper Android Library written in Kotlin) Mobile Development Digest #98 (No more SMS \u0026amp; Call Log permissions, Now what?) MindOrks Newsletter #27 (No more SMS \u0026amp; Call Log permissions, Now what?) MindOrks Newsletter #22 (How did I automate the generation of release APK) Android Weekly #337 (How did I automate the generation of release APK) Android Weekly #321 (Awesome List Of Online Tools For Android Developers) MindOrks Newsletter #10 (Awesome List Of Online Tools For Android Developers) Android LibHunt #111 (Awesome List Of Online Tools For Android Developers) MindOrks Newsletter #4 (Lint‚Äôs STOPSHIP can save you from pushing your buggy code to production)  StackOverflow profile     Thank you! ","description":"Naveen T P","id":7,"section":"","tags":null,"title":"About","uri":"https://naveentp.github.io/about/"},{"content":"   Here is a riddle to solve: I spend most of my time looking at Gradle scripts to run, but never loses hope. Who am I?\nThat‚Äôs right! I am an Android developer.\n Android Gradle build times are really slow. Especially when you have a huge code base, less RAM and using Android studio to run the scriptsüò™. But fortunately, we have terminal. Running gradle scripts using terminal saves lots of time.\nSo, let‚Äôs see how we can use the terminal and Gradle script to automate the process of building and generating apk.\n‚Ä¢ ‚Ä¢ ‚Ä¢ Problem Statement I have an android project with three different product flavours Staging, QA, Production. All three flavours has its own end points, and other configurations.\nThree flavours of a sample app   Now, I want to,\n Generate debug apks for all 3 flavours. Generate signed apks for all 3 flavours (Let‚Äôs consider, all 3 flavours uses same keystore and signing configs) Generate Production (Signed) apk for release.   In these 3 scenarios, Using AS, If I want to build an apk for a particular flavour, I would go to Build ‚Üí Select Build variant ‚Üí Choose module ‚Üí select build variant. This process would be a bit cumbersome task as I need to redo the process three times in case I want to build for all three flavours. Also, I cannot count on gradle build which is triggered through AS.\n‚Ä¢ ‚Ä¢ ‚Ä¢ Solution  Groovy + terminal = ‚ö°Ô∏è üöÄÔ∏è\n Gradle provides a domain specific language, or DSL, for describing builds. This build language is based on Groovy. In our solution will use some gradle scripts to automate the generation of apks using terminal command.\nStep 1: Let us store signing keystore information like path_to_keystore_file, alias, passwords in a properties file out of the version control system.\nSigning config properties file.   Step 2: Let‚Äôs write some gradle script to read the above file and use those signing credentials to generate Production signed apk.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import java.nio.file.Paths /* * Automates generation of Release APK * ./gradlew assembleRelease * */ Properties props = new Properties() def userHome = Paths.get(System.getProperty(\u0026#39;user.home\u0026#39;)); def propFile = file(userHome.resolve(\u0026#39;PATH_TO_SIGNING_CONFIG_PROPERTIES_FILE.properties\u0026#39;)) if (propFile.canRead()) { props.load(new FileInputStream(propFile)) if (props != null \u0026amp;\u0026amp; props.containsKey(\u0026#39;STORE_FILE\u0026#39;) \u0026amp;\u0026amp; props.containsKey(\u0026#39;KEY_STORE_PASSWORD\u0026#39;) \u0026amp;\u0026amp; props.containsKey(\u0026#39;KEY_ALIAS\u0026#39;) \u0026amp;\u0026amp; props.containsKey(\u0026#39;KEY_PASSWORD\u0026#39;)) { android.signingConfigs.release.storeFile = file(props[\u0026#39;STORE_FILE\u0026#39;]) android.signingConfigs.release.storePassword = props[\u0026#39;KEY_STORE_PASSWORD\u0026#39;] android.signingConfigs.release.keyAlias = props[\u0026#39;KEY_ALIAS\u0026#39;] android.signingConfigs.release.keyPassword = props[\u0026#39;KEY_PASSWORD\u0026#39;] } else { println \u0026#39;signing.properties found but some entries are missing\u0026#39; android.buildTypes.release.signingConfig = null } } else { println \u0026#39;signing.properties not found\u0026#39; android.buildTypes.release.signingConfig = null }   A script that automates the generation of Signed apk 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  /* Module level build.gradle */ android { defaultConfig { ... flavorDimensions \u0026#34;default\u0026#34; } signingConfigs { release } buildTypes { release { ... signingConfig signingConfigs.release } /* * To let gradle automate signing process, lintOptions to be added * */ lintOptions { checkReleaseBuilds false abortOnError false } }   Necessary changes to the module build.gradle  Place the above script at the end of your module level build.gradle file. The above script finds the property file, and sets the config provided. Also notice that I have added lintOptions which ignores errors at build time. This is needed for our automate script to work.\nStep 3: Now, Let‚Äôs ditch our good old Android studio way of building an application. Let‚Äôs use terminal instead for all our build purposes. Once you complete editing the build.gradle and after the sync completes, Gradle creates the following build variants.\nProduct flavours   If we go back and relook at our problem statement, we can now achieve all three cases in terminal like below. It‚Äôs as simple as u run any other terminal command.\n  ‚Ä¢ ‚Ä¢ ‚Ä¢ Advantages:  Productivity ‚Äî Saves build time using terminal Confidential ‚Äî Keeping properties file out of the version control(git, svn etc.,) and you still be able to sign the apk using the script CI \u0026amp; CD ‚Äî When using Jenkins or any other tool for continuous integration, terminal commands and scripts come in handy to generate multiple apks for targeted testings. Signed APK ‚Äî Generates signed apk without providing the signing configs each and every time.    Thats all folks!\n Buy me a coffee\nIf you like this article, you can buy me a coffee. Thanks!\n ","description":"Automating the the generation of release APK using groovy \u0026 terminal commands","id":8,"section":"posts","tags":["android","gradle"],"title":"How did I automate the generation of Release APK","uri":"https://naveentp.github.io/posts/automate-release-apk/"},{"content":"Photo by Kristaps Grundsteins on Unsplash  Have you anytime come across the situation where you published your app to playstore and recalling the bug that you left unfixed?    If yes, then this article is for you.   Android Lint is one of the most important and powerful static analysis tool that we are not using to its fullest. We can customise lint in our build.gradle to avoid accidentally pushing the known bugs to production.   Add this code block in your app‚Äôs build.gradle file. 1 2 3 4 5 6  // build.gradle android { lintOptions { fatal \u0026#39;StopShip\u0026#39; } }   To avoid your unresolved buggy code not to hit production, just add the comment //STOPSHIP right in your codebase to fix the bug later.\nAnd you are done!\nAt the time of building your app for playstore, If the lint finds out the comment in your codebase, it will break the build. So, You can go back to the code base, fix the known bug before publishing the app to production.\nRelease build will fail when lint finds STOPSHIP in code base    Lint will check the codebase during release build even if you are not running lint, as checkReleaseBuilds is by default true. There are about 42 user configurable lint fatal severities, STOPSHIP is one of those. You can go through each one of them, whichever suits your requirement you can implement it in your build.gradle.   If you like this article, you can buy me a coffee. Thanks!\n","description":"Lets learn how to avoid accidentally pushing the known bugs to production","id":10,"section":"posts","tags":["android","gradle"],"title":"Lint‚Äôs STOPSHIP can save you from pushing your buggy code to production","uri":"https://naveentp.github.io/posts/lint-stopship/"}]