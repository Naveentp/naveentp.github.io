[{"content":"  Core data migrations are easier said than done, isn‚Äôt it? One wrong step and we are doomed. üò•\nComing from an Android background (where the platform allows writing raw SQLite queries in the migration), it feels tough to handle manual migration on iOS. Although I love the fact that lightweight migration works out of the box, when it comes to other types of migrations, it‚Äôs just too many tasks to remember, and it feels like I‚Äôm defusing a bomb.\nContext We have recently seen duplicate records saved in one of our entities. Our investigation made it clear that the uniqueId parameter (column) we have in the entity isn‚Äôt unique and is an optional parameter.\nThough we had implemented a code logic that handles upsert operation (update/insert the record based on the record availability in the entity), it was not sufficient. The duplicate record will still be saved if there‚Äôs a race condition. So, we decided to solve this at the database level.\nWhen I started working on it, I referred to a lot of documentation \u0026amp; resources but couldn‚Äôt get complete information. Most of the articles only talked about lightweight migration. Now that we have successfully migrated, I am sharing my learnings here and hope that it will help somebody who is dealing with a similar problem.\nLet‚Äôs jump right into it.\nPhoto by Vitolda Klein on Unsplash   Existing Set-up For better understanding, I‚Äôve created a sample project with a single entity, UserEntity, in its data model.\nUserEntity with its parameters. Observe UniqueId is an optional parameter here.   Core data creates a table in SQLite under the hood when we run the project. The generated table structure can be seen below. A minor detail to observe here is the naming convention ‚Äî table name \u0026amp; parameter names starts with Z, and PrimaryKey Z_PK is internally created and handled.\nUserEntity table created in SQLite under the hood.   CREATE TABLE ZUSERENTITY ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER, ZAGE INTEGER, ZNAME VARCHAR, ZUNIQUEID VARCHAR ) With this setup, every time we insert a record, Core data treats it as a new record. Hence it can store duplicate records (even when uniqueId is the same) as no unique constraint has been set.\nIf the app is still under development, we could make the necessary changes on UserEntity to not accept duplicate records. What if this implementation has already been rolled-out to production, users already using the app, and they see duplicate records? Now, only a migration can fix the issue.\nCore data migration process  Create a second version of the data model and set it as a current model. This creates a copy of the existing data model.   \nAdd uniqueId parameter in UserEntity‚Äôs Constraints section in the data model v2. This adds a unique constraint to the parameter.   \nSet NSMergePolicy to handle the merge conflict while inserting the record. Use context.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump. This MergePolicy asks Core data to merge duplicate objects based on their properties. So, if a record with the same uniqueId is already present, Core data will update the existing record instead of inserting a new one.  A sample implementation of NSMergePolicy   When we run the app, the migration would fail as lightweight migration cannot handle the unique constraint migration. This needs a manual migration with the help of the mapping model.\n NSUnderlyingException=Constraint unique violation: UNIQUE constraint failed: ZUSERENTITY.ZUNIQUEID, reason=constraint violation during attempted migration, NSExceptionOmitCallstacks=true}}}, [\"reason\": Cannot migrate store in-place: constraint violation during attempted migration, \"NSUnderlyingError\": Error Domain=NSCocoaErrorDomain Code=134111 \"(null)\"  Let‚Äôs create a mapping model by selecting v1 as the source data model and v2 as the target data model.  \nCreating a mapping model is insufficient because it only maps the old records to the new data model. If we run the app, it would still crash by showing the same error. So, how do we solve the unique constraint exception?\nThe answer is to use NSEntityMigrationPolicy\nThe app crashes when we run the app because Core data wouldn‚Äôt know how to handle the existing duplicate records (if any). Since we have set the unique constraint to uniqueId, we should remove the existing duplicate records from the source data model before the migration takes place.\nSo, let‚Äôs create a custom MigrationPolicy that deletes the duplicate records.  Sample code snippet to remove duplicate records from the source context   NSEntityMigrationPolicy has a begin(mapping:manager) function that the migration manager invokes at the start of the given entity mapping. We are making use of this function to run our code snippet. This code snippet gets all the records from sourceContext‚Äôs UserEntity and deletes duplicate records if any.\nThe final step is to tell the Core data to use this MigrationPolicy when migrating the UserEntity table. We can do so by specifying the fully name-spaced class name of MigrationPolicy_v1_v2 in the MappingModel. Make sure the entity mapping Type changes from copy to custom once you add the custom policy.   Final words Were we able to run the migration successfully? Oh yeah!\n\nIf we do all these steps correctly and run the app, Core data migration succeeds and removes the existing duplicate records as well. Any future insertions will avoid duplicates by updating the existing record if it is already available in the table.\n‚Ä¢ ‚Ä¢ ‚Ä¢ I have created a sample app to implement \u0026amp; test the functionality. You can refer to the source code for a detailed understanding.\nSo, that\u0026rsquo;s everything for today.\nOriginally published on SignEasy blog.\n Buy me a coffee?\nIf you like this article, you can buy me a coffee. Thanks!\n ","description":"A step-by-step guide to setting a unique constraints to a parameter to avoid duplicates","id":2,"section":"posts","tags":["iOS","Core Data"],"title":"Core Data Migration to Avoid Duplicate Entries","uri":"https://naveentp.github.io/posts/core-data-migration-to-avoid-duplicates/"},{"content":"  As an Android developer, I always wanted to see how people would react to my apps. There are several ways a user could give feedback - through an email, over social media networks like Twitter, etc. But Play store rating and review is always been a crucial part of any app. It will not only help us getting the user feedback but on the other hand, it helps users to decide which app to choose from a similar category based on the ratings.\nThat being said, how would you encourage your users to give feedback on your app? You either provide a button asking Review somewhere in the NavigationDrawer/Toolbar or trigger the review popup after a user has experienced enough of your app. But when a user clicks on the button, we usually end up redirecting the user to the Play store app detail screenüòë We never wanted our customers to leave our application, but with this flow, we were forced to redirect the control to Play store app.\n‚Ä¢ ‚Ä¢ ‚Ä¢ But Google finally heard us! They have introduced a new shiny API for in-app review functionalityüòé With this API we can present a popup \u0026amp; ask for Review inside the app without having to redirect to Playstore. That‚Äôs Awesome, isn\u0026rsquo;t it? Let‚Äôs learn all about it in this article.\nMinimum requirements  Android devices should be running on Android 5.0 (API level 21) or higher and should have Google play store installed. Chrome OS devices that have Google play store app installed. Play core library with v1.8.0 or higher.  Design guidelines \u0026amp; Quota restrictions  The Review card (popup) should not be tampered or altered by modifying the design. Any overlay should not be added on top or around the card. Review dialog should not be programmatically removed (It will automatically be removed based on user actions) To protect user privacy and avoid API misuse, this API has a limited quota per user. Hence this functionality should not be triggered on a button click. Before presenting the Review card, the app should not ask user opinions like ‚ÄúDo you like the app?‚Äù or ‚ÄúGive this app 5 stars‚Äù, etc.  ‚Ä¢ ‚Ä¢ ‚Ä¢ Let‚Äôs Implement!  Add play-core library as a dependency in your build.gradle file.  1  implementation \u0026#39;com.google.android.play:core:1.8.0\u0026#39;   Create a ReviewManager instance and request ReviewInfo object. The ReviewInfo object to be pre-cached before calling launchReviewFlow method. So, it should be fetched ahead of time.  1 2 3 4 5 6 7 8 9 10 11  private var reviewInfo: ReviewInfo? = null val manager = ReviewManagerFactory.create(context) val request = manager.requestReviewFlow() requestFlow.addOnCompleteListener { request -\u0026gt; if (request.isSuccessful) { //Received ReviewInfo object  reviewInfo = request.result } else { //Problem in receiving object  reviewInfo = null }   Now, you can trigger launchReviewFlow to present the Review card to the user. It is suggested to show the review flow after the user has experienced enough of your app or game.  1 2 3 4 5 6  reviewInfo?.let { val flow = reviewManager.launchReviewFlow(this@MainActivity, it) flow.addOnCompleteListener { //Irrespective of the result, the app flow should continue  } }   That‚Äôs it! your app is all set‚úåÔ∏è\n‚Ä¢ ‚Ä¢ ‚Ä¢ Testing While I was testing the app, I made a few mistakes. I‚Äôll list it out here so that you won‚Äôt make the same mistakes that I did.\n We often test the new functionalities by creating a new project that would have new ApplicationId. In this case, while you test the app, make sure you give an ApplicationId that is already released and available in the play store. If you have given feedback in the past for your app, in-app review API‚Äôs launchReviewFlow will not present any Review card. It simply triggers a success event. Due to quota limitations, calling a launchReviewFlow method might not always display a dialog. It should not be linked with any button click event. To test one of my apps, I had to create a signed apk to see the Review card but for the other app, debug build worked just fine. To check other design guidelines and when to display a review card, refer to the official document here.  ‚Ä¢ ‚Ä¢ ‚Ä¢ I have created a sample app to implement \u0026amp; test the functionality. You can refer to the source code for more understanding.\nThat‚Äôs everything for today.\n Buy me a coffee?\nIf you like this article, you can buy me a coffee. Thanks!\n ","description":"Exploring Android's new In-app review API","id":3,"section":"posts","tags":["android","in-app review"],"title":"Integrating In-App Review API into Android App","uri":"https://naveentp.github.io/posts/android-in-app-review-api/"},{"content":" \nHello worldüëã, I\u0026rsquo;m Naveen! About me  Software Engineer Native mobile app developer (#iOS, #Android) Open-source enthusiast I write technical stuff at Medium  Mentions  Android LibHunt #169 (Awesome Jetpack compose A collaborative list of awesome jetpack compose resources) Android Weekly #378 (Awesome Jetpack compose A collaborative list of awesome jetpack compose resources) Android LibHunt #156 (Clean-MVVM-NewsApp An Android application built using Clean + MVVM architecture) AndroidDev Digest #221 (Preference Helper Android Library written in Kotlin) Mobile Development Digest #98 (No more SMS \u0026amp; Call Log permissions, Now what?) MindOrks Newsletter #27 (No more SMS \u0026amp; Call Log permissions, Now what?) MindOrks Newsletter #22 (How did I automate the generation of release APK) Android Weekly #337 (How did I automate the generation of release APK) Android Weekly #321 (Awesome List Of Online Tools For Android Developers) MindOrks Newsletter #10 (Awesome List Of Online Tools For Android Developers) Android LibHunt #111 (Awesome List Of Online Tools For Android Developers) MindOrks Newsletter #4 (Lint‚Äôs STOPSHIP can save you from pushing your buggy code to production)  StackOverflow profile     Thank you! ","description":"Naveen T P","id":8,"section":"","tags":null,"title":"About","uri":"https://naveentp.github.io/about/"},{"content":"   Here is a riddle to solve: I spend most of my time looking at Gradle scripts to run, but never loses hope. Who am I?\nThat‚Äôs right! I am an Android developer.\n Android Gradle build times are really slow. Especially when you have a huge code base, less RAM and using Android studio to run the scriptsüò™. But fortunately, we have terminal. Running gradle scripts using terminal saves lots of time.\nSo, let‚Äôs see how we can use the terminal and Gradle script to automate the process of building and generating apk.\n‚Ä¢ ‚Ä¢ ‚Ä¢ Problem Statement I have an android project with three different product flavours Staging, QA, Production. All three flavours has its own end points, and other configurations.\nThree flavours of a sample app   Now, I want to,\n Generate debug apks for all 3 flavours. Generate signed apks for all 3 flavours (Let‚Äôs consider, all 3 flavours uses same keystore and signing configs) Generate Production (Signed) apk for release.   In these 3 scenarios, Using AS, If I want to build an apk for a particular flavour, I would go to Build ‚Üí Select Build variant ‚Üí Choose module ‚Üí select build variant. This process would be a bit cumbersome task as I need to redo the process three times in case I want to build for all three flavours. Also, I cannot count on gradle build which is triggered through AS.\n‚Ä¢ ‚Ä¢ ‚Ä¢ Solution  Groovy + terminal = ‚ö°Ô∏è üöÄÔ∏è\n Gradle provides a domain specific language, or DSL, for describing builds. This build language is based on Groovy. In our solution will use some gradle scripts to automate the generation of apks using terminal command.\nStep 1: Let us store signing keystore information like path_to_keystore_file, alias, passwords in a properties file out of the version control system.\nSigning config properties file.   Step 2: Let‚Äôs write some gradle script to read the above file and use those signing credentials to generate Production signed apk.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import java.nio.file.Paths /* * Automates generation of Release APK * ./gradlew assembleRelease * */ Properties props = new Properties() def userHome = Paths.get(System.getProperty(\u0026#39;user.home\u0026#39;)); def propFile = file(userHome.resolve(\u0026#39;PATH_TO_SIGNING_CONFIG_PROPERTIES_FILE.properties\u0026#39;)) if (propFile.canRead()) { props.load(new FileInputStream(propFile)) if (props != null \u0026amp;\u0026amp; props.containsKey(\u0026#39;STORE_FILE\u0026#39;) \u0026amp;\u0026amp; props.containsKey(\u0026#39;KEY_STORE_PASSWORD\u0026#39;) \u0026amp;\u0026amp; props.containsKey(\u0026#39;KEY_ALIAS\u0026#39;) \u0026amp;\u0026amp; props.containsKey(\u0026#39;KEY_PASSWORD\u0026#39;)) { android.signingConfigs.release.storeFile = file(props[\u0026#39;STORE_FILE\u0026#39;]) android.signingConfigs.release.storePassword = props[\u0026#39;KEY_STORE_PASSWORD\u0026#39;] android.signingConfigs.release.keyAlias = props[\u0026#39;KEY_ALIAS\u0026#39;] android.signingConfigs.release.keyPassword = props[\u0026#39;KEY_PASSWORD\u0026#39;] } else { println \u0026#39;signing.properties found but some entries are missing\u0026#39; android.buildTypes.release.signingConfig = null } } else { println \u0026#39;signing.properties not found\u0026#39; android.buildTypes.release.signingConfig = null }   A script that automates the generation of Signed apk 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  /* Module level build.gradle */ android { defaultConfig { ... flavorDimensions \u0026#34;default\u0026#34; } signingConfigs { release } buildTypes { release { ... signingConfig signingConfigs.release } /* * To let gradle automate signing process, lintOptions to be added * */ lintOptions { checkReleaseBuilds false abortOnError false } }   Necessary changes to the module build.gradle  Place the above script at the end of your module level build.gradle file. The above script finds the property file, and sets the config provided. Also notice that I have added lintOptions which ignores errors at build time. This is needed for our automate script to work.\nStep 3: Now, Let‚Äôs ditch our good old Android studio way of building an application. Let‚Äôs use terminal instead for all our build purposes. Once you complete editing the build.gradle and after the sync completes, Gradle creates the following build variants.\nProduct flavours   If we go back and relook at our problem statement, we can now achieve all three cases in terminal like below. It‚Äôs as simple as u run any other terminal command.\n  ‚Ä¢ ‚Ä¢ ‚Ä¢ Advantages:  Productivity ‚Äî Saves build time using terminal Confidential ‚Äî Keeping properties file out of the version control(git, svn etc.,) and you still be able to sign the apk using the script CI \u0026amp; CD ‚Äî When using Jenkins or any other tool for continuous integration, terminal commands and scripts come in handy to generate multiple apks for targeted testings. Signed APK ‚Äî Generates signed apk without providing the signing configs each and every time.    Thats all folks!\n Buy me a coffee\nIf you like this article, you can buy me a coffee. Thanks!\n ","description":"Automating the the generation of release APK using groovy \u0026 terminal commands","id":9,"section":"posts","tags":["android","gradle"],"title":"How did I automate the generation of Release APK","uri":"https://naveentp.github.io/posts/automate-release-apk/"},{"content":"Photo by Kristaps Grundsteins on Unsplash  Have you anytime come across the situation where you published your app to playstore and recalling the bug that you left unfixed?    If yes, then this article is for you.   Android Lint is one of the most important and powerful static analysis tool that we are not using to its fullest. We can customise lint in our build.gradle to avoid accidentally pushing the known bugs to production.   Add this code block in your app‚Äôs build.gradle file. 1 2 3 4 5 6  // build.gradle android { lintOptions { fatal \u0026#39;StopShip\u0026#39; } }   To avoid your unresolved buggy code not to hit production, just add the comment //STOPSHIP right in your codebase to fix the bug later.\nAnd you are done!\nAt the time of building your app for playstore, If the lint finds out the comment in your codebase, it will break the build. So, You can go back to the code base, fix the known bug before publishing the app to production.\nRelease build will fail when lint finds STOPSHIP in code base    Lint will check the codebase during release build even if you are not running lint, as checkReleaseBuilds is by default true. There are about 42 user configurable lint fatal severities, STOPSHIP is one of those. You can go through each one of them, whichever suits your requirement you can implement it in your build.gradle.   If you like this article, you can buy me a coffee. Thanks!\n","description":"Lets learn how to avoid accidentally pushing the known bugs to production","id":11,"section":"posts","tags":["android","gradle"],"title":"Lint‚Äôs STOPSHIP can save you from pushing your buggy code to production","uri":"https://naveentp.github.io/posts/lint-stopship/"}]