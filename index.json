[{"content":" \nHello worldüëã, I\u0026rsquo;m Naveen! About me  Software Engineer Native mobile app developer (#iOS, #Android) Open-source enthusiast I write technical stuff at Medium  Mentions  Android LibHunt #169 (Awesome Jetpack compose A collaborative list of awesome jetpack compose resources) Android Weekly #378 (Awesome Jetpack compose A collaborative list of awesome jetpack compose resources) Android LibHunt #156 (Clean-MVVM-NewsApp An Android application built using Clean + MVVM architecture) AndroidDev Digest #221 (Preference Helper Android Library written in Kotlin) Mobile Development Digest #98 (No more SMS \u0026amp; Call Log permissions, Now what?) MindOrks Newsletter #27 (No more SMS \u0026amp; Call Log permissions, Now what?) MindOrks Newsletter #22 (How did I automate the generation of release APK) Android Weekly #337 (How did I automate the generation of release APK) Android Weekly #321 (Awesome List Of Online Tools For Android Developers) MindOrks Newsletter #10 (Awesome List Of Online Tools For Android Developers) Android LibHunt #111 (Awesome List Of Online Tools For Android Developers) MindOrks Newsletter #4 (Lint‚Äôs STOPSHIP can save you from pushing your buggy code to production)  StackOverflow profile     Thank you! ","description":"Naveen T P","id":6,"section":"","tags":null,"title":"About","uri":"https://naveentp.github.io/about/"},{"content":"   Here is a riddle to solve: I spend most of my time looking at Gradle scripts to run, but never loses hope. Who am I?\nThat‚Äôs right! I am an Android developer.\n Android Gradle build times are really slow. Especially when you have a huge code base, less RAM and using Android studio to run the scriptsüò™. But fortunately, we have terminal. Running gradle scripts using terminal saves lots of time.\nSo, let‚Äôs see how we can use the terminal and Gradle script to automate the process of building and generating apk.\n‚Ä¢ ‚Ä¢ ‚Ä¢ Problem Statement I have an android project with three different product flavours Staging, QA, Production. All three flavours has its own end points, and other configurations.\nThree flavours of a sample app   Now, I want to,\n Generate debug apks for all 3 flavours. Generate signed apks for all 3 flavours (Let‚Äôs consider, all 3 flavours uses same keystore and signing configs) Generate Production (Signed) apk for release.   In these 3 scenarios, Using AS, If I want to build an apk for a particular flavour, I would go to Build ‚Üí Select Build variant ‚Üí Choose module ‚Üí select build variant. This process would be a bit cumbersome task as I need to redo the process three times in case I want to build for all three flavours. Also, I cannot count on gradle build which is triggered through AS.\n‚Ä¢ ‚Ä¢ ‚Ä¢ Solution  Groovy + terminal = ‚ö°Ô∏è üöÄÔ∏è\n Gradle provides a domain specific language, or DSL, for describing builds. This build language is based on Groovy. In our solution will use some gradle scripts to automate the generation of apks using terminal command.\nStep 1: Let us store signing keystore information like path_to_keystore_file, alias, passwords in a properties file out of the version control system.\nSigning config properties file.   Step 2: Let‚Äôs write some gradle script to read the above file and use those signing credentials to generate Production signed apk.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import java.nio.file.Paths /* * Automates generation of Release APK * ./gradlew assembleRelease * */ Properties props = new Properties() def userHome = Paths.get(System.getProperty(\u0026#39;user.home\u0026#39;)); def propFile = file(userHome.resolve(\u0026#39;PATH_TO_SIGNING_CONFIG_PROPERTIES_FILE.properties\u0026#39;)) if (propFile.canRead()) { props.load(new FileInputStream(propFile)) if (props != null \u0026amp;\u0026amp; props.containsKey(\u0026#39;STORE_FILE\u0026#39;) \u0026amp;\u0026amp; props.containsKey(\u0026#39;KEY_STORE_PASSWORD\u0026#39;) \u0026amp;\u0026amp; props.containsKey(\u0026#39;KEY_ALIAS\u0026#39;) \u0026amp;\u0026amp; props.containsKey(\u0026#39;KEY_PASSWORD\u0026#39;)) { android.signingConfigs.release.storeFile = file(props[\u0026#39;STORE_FILE\u0026#39;]) android.signingConfigs.release.storePassword = props[\u0026#39;KEY_STORE_PASSWORD\u0026#39;] android.signingConfigs.release.keyAlias = props[\u0026#39;KEY_ALIAS\u0026#39;] android.signingConfigs.release.keyPassword = props[\u0026#39;KEY_PASSWORD\u0026#39;] } else { println \u0026#39;signing.properties found but some entries are missing\u0026#39; android.buildTypes.release.signingConfig = null } } else { println \u0026#39;signing.properties not found\u0026#39; android.buildTypes.release.signingConfig = null }   A script that automates the generation of Signed apk 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  /* Module level build.gradle */ android { defaultConfig { ... flavorDimensions \u0026#34;default\u0026#34; } signingConfigs { release } buildTypes { release { ... signingConfig signingConfigs.release } /* * To let gradle automate signing process, lintOptions to be added * */ lintOptions { checkReleaseBuilds false abortOnError false } }   Necessary changes to the module build.gradle  Place the above script at the end of your module level build.gradle file. The above script finds the property file, and sets the config provided. Also notice that I have added lintOptions which ignores errors at build time. This is needed for our automate script to work.\nStep 3: Now, Let‚Äôs ditch our good old Android studio way of building an application. Let‚Äôs use terminal instead for all our build purposes. Once you complete editing the build.gradle and after the sync completes, Gradle creates the following build variants.\nProduct flavours   If we go back and relook at our problem statement, we can now achieve all three cases in terminal like below. It‚Äôs as simple as u run any other terminal command.\n  ‚Ä¢ ‚Ä¢ ‚Ä¢ Advantages:  Productivity ‚Äî Saves build time using terminal Confidential ‚Äî Keeping properties file out of the version control(git, svn etc.,) and you still be able to sign the apk using the script CI \u0026amp; CD ‚Äî When using Jenkins or any other tool for continuous integration, terminal commands and scripts come in handy to generate multiple apks for targeted testings. Signed APK ‚Äî Generates signed apk without providing the signing configs each and every time.    Thats all folks!\nIf you like this article, you can buy me a coffee. Thanks!\n","description":"Automating the the generation of release APK using groovy \u0026 terminal commands","id":7,"section":"posts","tags":["android","gradle"],"title":"How did I automate the generation of Release APK","uri":"https://naveentp.github.io/posts/automate-release-apk/"},{"content":"Photo by Kristaps Grundsteins on Unsplash  Have you anytime come across the situation where you published your app to playstore and recalling the bug that you left unfixed?    If yes, then this article is for you.   Android Lint is one of the most important and powerful static analysis tool that we are not using to its fullest. We can customise lint in our build.gradle to avoid accidentally pushing the known bugs to production.   Add this code block in your app‚Äôs build.gradle file. 1 2 3 4 5 6  // build.gradle android { lintOptions { fatal \u0026#39;StopShip\u0026#39; } }   To avoid your unresolved buggy code not to hit production, just add the comment //STOPSHIP right in your codebase to fix the bug later.\nAnd you are done!\nAt the time of building your app for playstore, If the lint finds out the comment in your codebase, it will break the build. So, You can go back to the code base, fix the known bug before publishing the app to production.\nRelease build will fail when lint finds STOPSHIP in code base    Lint will check the codebase during release build even if you are not running lint, as checkReleaseBuilds is by default true. There are about 42 user configurable lint fatal severities, STOPSHIP is one of those. You can go through each one of them, whichever suits your requirement you can implement it in your build.gradle.   If you like this article, you can buy me a coffee. Thanks!\n","description":"Lets learn how to avoid accidentally pushing the known bugs to production","id":9,"section":"posts","tags":["android","gradle"],"title":"Lint‚Äôs STOPSHIP can save you from pushing your buggy code to production","uri":"https://naveentp.github.io/posts/lint-stopship/"}]